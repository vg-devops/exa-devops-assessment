name: DEPLOYMENT

on:
  workflow_dispatch:
    inputs:
      start_environment:
        description: 'Choose deployment environment...'
        required: true
        type: choice
        options:
        - Development
        - Testing
        - Staging
        - Production

env:
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
  NAMESPACE: ${{ secrets.NAMESPACE }}
  CI_WORKFLOW_NAME: "BUILD"

jobs:
  fetch_latest_build:
    runs-on: ubuntu-latest
    outputs:
      docker_tag: ${{ steps.get_build_info.outputs.docker_tag }}
    steps:
    - name: Get latest successful Build ID
      id: get_build_run
      uses: actions/github-script@v6
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
            // List and print all repo workflows
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            console.log("Available workflows:");
            workflows.workflows.forEach(wf => console.log(wf.name));
 
            const ciWorkflow = workflows.workflows.find(wf => wf.name === process.env.CI_WORKFLOW_NAME);
            if (!ciWorkflow) {
              core.setFailed(`Workflow "${process.env.CI_WORKFLOW_NAME}" not found`);
              return;
            }
  
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: ciWorkflow.id,
              status: 'success',
              branch: 'feature/TKT-000',
              per_page: 1
            });
       
            core.setOutput('run_id', runs.workflow_runs[0].id);
            console.log(`Latest successful run ID: ${runs.workflow_runs[0].id}`);            

    - name: Download latest artifact
      uses: actions/download-artifact@v4
      with:
        name: build-info
        path: ./
        run-id: ${{ steps.get_build_run.outputs.run_id }}
        github-token: ${{secrets.GITHUB_TOKEN}} 

    - name: Obtain build information
      id: get_build_info
      run: |
        DOCKER_TAG=$(cat build_info.txt)
        echo "docker_tag=${DOCKER_TAG}"
        echo "docker_tag=${DOCKER_TAG}" >> $GITHUB_OUTPUT

  deploy:
    needs: fetch_latest_build
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.start_environment }}

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        mask-aws-account-id: true

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: 'true'    

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.30.0'

    # - name: tempo debug
    #   run: |
    #     echo "Selected Environment: ${{ github.event.inputs.start_environment }}"
    #     echo "Current Environment: ${{ env.ENVIRONMENT }}"
    #     if [ -n "${{ secrets.EKS_CLUSTER_NAME }}" ]; then
    #       echo "EKS_CLUSTER_NAME is set"
    #     else
    #       echo "EKS_CLUSTER_NAME is not set"
    #     fi

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

    - name: Checkout Current repository
      uses: actions/checkout@v4

    - name: Update Kubernetes.yaml with env vars/secrets
      run: |
        sed -i 's/{NAMESPACE}/${{ env.NAMESPACE }}/g' kubernetes.yaml
        sed -i 's/{APP_NAME_FROM_REPOSITORY}/${{ github.event.repository.name }}/g' kubernetes.yaml
        sed -i 's|{IMAGE}|${{ env.ECR_REGISTRY }}/${{ github.event.repository.name }}:${{ needs.fetch_latest_build.outputs.docker_tag }}|g' kubernetes.yaml
        cat kubernetes.yaml

    - name: Cluster Deployment
      run: |
        kubectl apply -f kubernetes.yaml 
        kubectl rollout status deploy/${{ github.event.repository.name }}-deployment -n ${{ env.NAMESPACE }} \
        || (echo "Rolling back deployment:" \
            && kubectl rollout undo deploy/${{ github.event.repository.name }}-deployment -n ${{ env.NAMESPACE }}  \
            && exit 1)

    - name: Deployment Status
      if: success()
      run: |
        echo "Deployed ${{ needs.fetch_latest_build.outputs.docker_tag }} to ${{ github.event.inputs.environment }}"        
